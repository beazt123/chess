{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'equals()' and 'hashCode()' not paired",
  "severity": "High",
  "comment": "Class has 'equals()' defined but does not define 'hashCode()'",
  "detailsInfo": "Reports classes that override the 'equals()' method but do not override the 'hashCode()' method or vice versa, which can potentially lead to problems when the class is added to a 'Collection' or a 'HashMap'. The quick-fix generates the default implementation for an absent method. Example: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' After the quick-fix is applied: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/board/Move.java",
      "language": "JAVA",
      "line": 98,
      "offset": 29,
      "length": 9,
      "code": {
        "startLine": 96,
        "length": 9,
        "offset": 98,
        "surroundingCode": "\n  // Separating the same type of class into many types of subclasses\n  public static final class MajorMove extends Move {\n\n    public MajorMove(Board board, Piece piece, int destinationCoordinate) {"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "EqualsAndHashcode"
  },
  "hash": "c8ba9ef6fe2f8a762135ea685c41abad3478b92a6ff1696f45a58c54c7d27bd8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'equals()' and 'hashCode()' not paired",
  "severity": "High",
  "comment": "Class has 'equals()' defined but does not define 'hashCode()'",
  "detailsInfo": "Reports classes that override the 'equals()' method but do not override the 'hashCode()' method or vice versa, which can potentially lead to problems when the class is added to a 'Collection' or a 'HashMap'. The quick-fix generates the default implementation for an absent method. Example: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' After the quick-fix is applied: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/board/Move.java",
      "language": "JAVA",
      "line": 151,
      "offset": 23,
      "length": 15,
      "code": {
        "startLine": 149,
        "length": 15,
        "offset": 27,
        "surroundingCode": "  }\n\n  public static class MajorAttackMove extends AttackMove {\n    public MajorAttackMove(\n        final Board board,"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "EqualsAndHashcode"
  },
  "hash": "3ec281482494c7003e2f873c6f56e0eb1affef250f4a2a6653bdf917437ad767"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'equals()' and 'hashCode()' not paired",
  "severity": "High",
  "comment": "Class has 'equals()' defined but does not define 'hashCode()'",
  "detailsInfo": "Reports classes that override the 'equals()' method but do not override the 'hashCode()' method or vice versa, which can potentially lead to problems when the class is added to a 'Collection' or a 'HashMap'. The quick-fix generates the default implementation for an absent method. Example: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' After the quick-fix is applied: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/board/Move.java",
      "language": "JAVA",
      "line": 193,
      "offset": 29,
      "length": 8,
      "code": {
        "startLine": 191,
        "length": 8,
        "offset": 33,
        "surroundingCode": "  }\n\n  public static final class PawnMove extends Move {\n    public PawnMove(Board board, Piece movedPiece, int destinationCoordinate) {\n      super(board, movedPiece, destinationCoordinate);"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "EqualsAndHashcode"
  },
  "hash": "171faabddddf7a7358ed3be7a1b42b391647761765177e74c7f372eed9b63aa7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'equals()' and 'hashCode()' not paired",
  "severity": "High",
  "comment": "Class has 'equals()' defined but does not define 'hashCode()'",
  "detailsInfo": "Reports classes that override the 'equals()' method but do not override the 'hashCode()' method or vice versa, which can potentially lead to problems when the class is added to a 'Collection' or a 'HashMap'. The quick-fix generates the default implementation for an absent method. Example: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' After the quick-fix is applied: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/board/Move.java",
      "language": "JAVA",
      "line": 209,
      "offset": 23,
      "length": 14,
      "code": {
        "startLine": 207,
        "length": 14,
        "offset": 27,
        "surroundingCode": "  }\n\n  public static class PawnAttackMove extends AttackMove {\n    public PawnAttackMove(\n        Board board, Piece piece, int destinationCoordinate, Piece attackedPiece) {"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "EqualsAndHashcode"
  },
  "hash": "aa2f71b4a047613ab644d6e96270ac306f95fd771006073d504d51b89e9e3714"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'equals()' and 'hashCode()' not paired",
  "severity": "High",
  "comment": "Class has 'equals()' defined but does not define 'hashCode()'",
  "detailsInfo": "Reports classes that override the 'equals()' method but do not override the 'hashCode()' method or vice versa, which can potentially lead to problems when the class is added to a 'Collection' or a 'HashMap'. The quick-fix generates the default implementation for an absent method. Example: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' After the quick-fix is applied: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/board/Move.java",
      "language": "JAVA",
      "line": 228,
      "offset": 29,
      "length": 23,
      "code": {
        "startLine": 226,
        "length": 23,
        "offset": 33,
        "surroundingCode": "  }\n\n  public static final class PawnEnPassantAttackMove extends PawnAttackMove {\n    public PawnEnPassantAttackMove(\n        Board board, Piece piece, int destinationCoordinate, Piece attackedPiece) {"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "EqualsAndHashcode"
  },
  "hash": "9f62460f797898d5a5615726de39e0b0bb3e5876464844b8a6446559d8a0c101"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'equals()' and 'hashCode()' not paired",
  "severity": "High",
  "comment": "Class has 'equals()' defined but does not define 'hashCode()'",
  "detailsInfo": "Reports classes that override the 'equals()' method but do not override the 'hashCode()' method or vice versa, which can potentially lead to problems when the class is added to a 'Collection' or a 'HashMap'. The quick-fix generates the default implementation for an absent method. Example: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' After the quick-fix is applied: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/board/Move.java",
      "language": "JAVA",
      "line": 350,
      "offset": 29,
      "length": 18,
      "code": {
        "startLine": 348,
        "length": 18,
        "offset": 33,
        "surroundingCode": "  }\n\n  public static final class KingSideCastleMove extends CastleMove {\n    public KingSideCastleMove(\n        Board board,"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "EqualsAndHashcode"
  },
  "hash": "c0272b9c245fa969b9e6c96ca56cd10661336e2d816b1fcc512999c2fb61bb4d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'equals()' and 'hashCode()' not paired",
  "severity": "High",
  "comment": "Class has 'equals()' defined but does not define 'hashCode()'",
  "detailsInfo": "Reports classes that override the 'equals()' method but do not override the 'hashCode()' method or vice versa, which can potentially lead to problems when the class is added to a 'Collection' or a 'HashMap'. The quick-fix generates the default implementation for an absent method. Example: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n}' After the quick-fix is applied: 'class StringHolder {\n  String s;\n\n  @Override public int hashCode() {\n    return s != null ? s.hashCode() : 0;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof StringHolder)) return false;\n\n    StringHolder holder = (StringHolder)o;\n\n    if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n    return true;\n  }\n}'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/board/Move.java",
      "language": "JAVA",
      "line": 378,
      "offset": 29,
      "length": 19,
      "code": {
        "startLine": 376,
        "length": 19,
        "offset": 33,
        "surroundingCode": "  }\n\n  public static final class QueenSideCastleMove extends CastleMove {\n    public QueenSideCastleMove(\n        Board board,"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "EqualsAndHashcode"
  },
  "hash": "1fda0ec160ddbe726cb05cd68f6583934add0612320ba4af0ece16836e1f327a"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Unnecessary 'continue' statement",
  "severity": "High",
  "comment": "'continue' is unnecessary as the last statement in a loop",
  "detailsInfo": "Reports 'continue' statements if they are the last reachable statements in the loop. These 'continue' statements are unnecessary and can be safely removed. Example: 'for (String element: elements) {\n    System.out.println();\n    continue;\n  }' After the quick-fix is applied: 'for (String element: elements) {\n    System.out.println();\n  }' The inspection doesn't analyze JSP files. Use the Ignore in then branch of 'if' statement with 'else' branch option to ignore 'continue' statements when they are placed in a 'then' branch of a complete 'if'-'else' statement. Example: 'for (String element: elements) {\n    if(element.isEmpty()) {\n      continue;\n    } else {\n      //...\n    }\n  }'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/pieces/King.java",
      "language": "JAVA",
      "line": 54,
      "offset": 11,
      "length": 8,
      "code": {
        "startLine": 52,
        "length": 8,
        "offset": 164,
        "surroundingCode": "            || isFirstRowExclusion(this.piecePosition, candidateLegalMove)\n            || isEighthRowExclusion(this.piecePosition, candidateLegalMove)) {\n          continue;\n        } else {\n          final Tile destinationTile = board.getTile(candidateDestinationCoordinate);"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "UnnecessaryContinue"
  },
  "hash": "f8610c959473c5b80961e4d0f5ef099ea3032287f35750e2c3fd639cb810c18f"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to 'Throwable.printStackTrace()' without arguments. Such statements are often used for temporary debugging and should be either removed from the production code or replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/gui/Table.java",
      "language": "JAVA",
      "line": 247,
      "offset": 11,
      "length": 15,
      "code": {
        "startLine": 245,
        "length": 15,
        "offset": 108,
        "surroundingCode": "        Table.get().moveMadeUpdate(PlayerType.COMPUTER);\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      } catch (ExecutionException e) {\n        e.printStackTrace();"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "27c59f020b6162fc7da517bdae4ea36b1367d319b523f7a858b4c83378f36d8f"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to 'Throwable.printStackTrace()' without arguments. Such statements are often used for temporary debugging and should be either removed from the production code or replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/gui/Table.java",
      "language": "JAVA",
      "line": 249,
      "offset": 11,
      "length": 15,
      "code": {
        "startLine": 247,
        "length": 15,
        "offset": 78,
        "surroundingCode": "        e.printStackTrace();\n      } catch (ExecutionException e) {\n        e.printStackTrace();\n      }\n    }"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "b01e2a0953eb4d925327a2bf5125f244b82d12b106c873543cc5fb2204c6479c"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to 'Throwable.printStackTrace()' without arguments. Such statements are often used for temporary debugging and should be either removed from the production code or replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/gui/Table.java",
      "language": "JAVA",
      "line": 407,
      "offset": 17,
      "length": 15,
      "code": {
        "startLine": 405,
        "length": 15,
        "offset": 144,
        "surroundingCode": "              add(new JLabel(new ImageIcon(ImageIO.read(new File(filePathToGreenDot)))));\n            } catch (IOException e) {\n              e.printStackTrace();\n            }\n          }"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "de5972d33efc0556eb0fc457d0297e945d4a01e8efb946cf3e83568fec91d460"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to 'Throwable.printStackTrace()' without arguments. Such statements are often used for temporary debugging and should be either removed from the production code or replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/gui/TakenPiecesPanel.java",
      "language": "JAVA",
      "line": 87,
      "offset": 11,
      "length": 15,
      "code": {
        "startLine": 85,
        "length": 15,
        "offset": 84,
        "surroundingCode": "        southPanel.add(imageLabel);\n      } catch (final IOException e) {\n        e.printStackTrace();\n      }\n    }"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "be4b0553bfc9c45f24198dc868d02f12da53ef4a0131300d41e21645281c8a4e"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Call to 'printStackTrace()'",
  "severity": "High",
  "comment": "Call to 'printStackTrace()' should probably be replaced with more robust logging",
  "detailsInfo": "Reports calls to 'Throwable.printStackTrace()' without arguments. Such statements are often used for temporary debugging and should be either removed from the production code or replaced with a more robust logging facility.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/gui/TakenPiecesPanel.java",
      "language": "JAVA",
      "line": 104,
      "offset": 11,
      "length": 15,
      "code": {
        "startLine": 102,
        "length": 15,
        "offset": 84,
        "surroundingCode": "        southPanel.add(imageLabel);\n      } catch (final IOException e) {\n        e.printStackTrace();\n      }\n    }"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "ThrowablePrintStackTrace"
  },
  "hash": "67536ba83637e1f91e41b997fa9f14f4408f8ffb76deb64d2e769442f1290b90"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-'String' objects or primitives into 'String's. A quick-fix is suggested to simplify the concatenation. Example: 'void foo(int x, int y) {\n    String s = \"\" + x + \" ; \" + y;\n  }' After the quick-fix is applied: 'void foo(int x, int y) {\n    String s = x + \" ; \" + y;\n  }'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/gui/TakenPiecesPanel.java",
      "language": "JAVA",
      "line": 81,
      "offset": 27,
      "length": 2,
      "code": {
        "startLine": 79,
        "length": 2,
        "offset": 156,
        "surroundingCode": "                    Paths.get(\"art\", \"simple\")\n                        + takenPiece.getPieceAlliance().toString().substring(0, 1)\n                        + \"\"\n                        + takenPiece.toString()));\n        final ImageIcon icon = new ImageIcon(image);"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "d3505814a6529781f41649df0df4195d8c331c2f91f3dc72482530005b7477b7"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string used in concatenation",
  "detailsInfo": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-'String' objects or primitives into 'String's. A quick-fix is suggested to simplify the concatenation. Example: 'void foo(int x, int y) {\n    String s = \"\" + x + \" ; \" + y;\n  }' After the quick-fix is applied: 'void foo(int x, int y) {\n    String s = x + \" ; \" + y;\n  }'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/gui/TakenPiecesPanel.java",
      "language": "JAVA",
      "line": 95,
      "offset": 19,
      "length": 2,
      "code": {
        "startLine": 93,
        "length": 2,
        "offset": 113,
        "surroundingCode": "        String fileName =\n            takenPiece.getPieceAlliance().toString().substring(0, 1)\n                + \"\"\n                + takenPiece.getPieceType().toString()\n                + \".gif\";"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "fc8a6be0246f7538c795a1b8dffe0a8913aaca3f4d58c6f85de1b283c0d08e1d"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Redundant String operation",
  "severity": "High",
  "comment": "Replace 'board.getTile(tileId).getPiece().getPieceAlliance().toString().substring(0, 1)' with 'board.getTile(tileId).getPiece().getPieceAlliance().toString().charAt(0)'",
  "detailsInfo": "Reports redundant 'String' constructors and calls to methods like 'toString()' or 'substring()' when they can be replaced with a simplified expression. For example, calls to these methods can be safely removed in cases like '\"string\".substring(0)', '\"string\".toString()', or 'new StringBuilder().toString().substring(1,3)'. Example: 'System.out.println(new String(\"message\"));' After the quick-fix is applied: 'System.out.println(\"message\");' Note that the quick-fix removes the redundant constructor, and this may affect 'String' referential equality. If you need to preserve it even though it is considered bad practice, suppress the warning or configure the settings to ignore redundant 'String' constructors. New in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/gui/Table.java",
      "language": "JAVA",
      "line": 427,
      "offset": 78,
      "length": 9,
      "code": {
        "startLine": 425,
        "length": 9,
        "offset": 125,
        "surroundingCode": "        try {\n          final String fileName =\n              board.getTile(tileId).getPiece().getPieceAlliance().toString().substring(0, 1)\n                  + board.getTile(tileId).getPiece().toString()\n                  + \".gif\";"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "StringOperationCanBeSimplified"
  },
  "hash": "e8599a7c6c1013c0c8a861a94ea5264b24619aa7243d3553474a155d2100cd28"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Redundant String operation",
  "severity": "High",
  "comment": "Replace 'takenPiece.getPieceAlliance().toString().substring(0, 1)' with 'takenPiece.getPieceAlliance().toString().charAt(0)'",
  "detailsInfo": "Reports redundant 'String' constructors and calls to methods like 'toString()' or 'substring()' when they can be replaced with a simplified expression. For example, calls to these methods can be safely removed in cases like '\"string\".substring(0)', '\"string\".toString()', or 'new StringBuilder().toString().substring(1,3)'. Example: 'System.out.println(new String(\"message\"));' After the quick-fix is applied: 'System.out.println(\"message\");' Note that the quick-fix removes the redundant constructor, and this may affect 'String' referential equality. If you need to preserve it even though it is considered bad practice, suppress the warning or configure the settings to ignore redundant 'String' constructors. New in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/gui/TakenPiecesPanel.java",
      "language": "JAVA",
      "line": 94,
      "offset": 54,
      "length": 9,
      "code": {
        "startLine": 92,
        "length": 9,
        "offset": 91,
        "surroundingCode": "      try {\n        String fileName =\n            takenPiece.getPieceAlliance().toString().substring(0, 1)\n                + \"\"\n                + takenPiece.getPieceType().toString()"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "StringOperationCanBeSimplified"
  },
  "hash": "8afe66a122cc803cb910a86ee764f4a6660be3177ccd50429bdac64c1f7ba67e"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Redundant String operation",
  "severity": "High",
  "comment": "Replace 'BoardUtils.getPositionAtCoordinate(this.movedPiece.getPiecePosition()).substring(0, 1)' with 'BoardUtils.getPositionAtCoordinate(this.movedPiece.getPiecePosition()).charAt(0)'",
  "detailsInfo": "Reports redundant 'String' constructors and calls to methods like 'toString()' or 'substring()' when they can be replaced with a simplified expression. For example, calls to these methods can be safely removed in cases like '\"string\".substring(0)', '\"string\".toString()', or 'new StringBuilder().toString().substring(1,3)'. Example: 'System.out.println(new String(\"message\"));' After the quick-fix is applied: 'System.out.println(\"message\");' Note that the quick-fix removes the redundant constructor, and this may affect 'String' referential equality. If you need to preserve it even though it is considered bad practice, suppress the warning or configure the settings to ignore redundant 'String' constructors. New in 2018.1",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/board/Move.java",
      "language": "JAVA",
      "line": 222,
      "offset": 85,
      "length": 9,
      "code": {
        "startLine": 220,
        "length": 9,
        "offset": 129,
        "surroundingCode": "    @Override\n    public String toString() {\n      return BoardUtils.getPositionAtCoordinate(this.movedPiece.getPiecePosition()).substring(0, 1)\n          + \"x\"\n          + BoardUtils.getPositionAtCoordinate(this.destinationCoordinate);"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "StringOperationCanBeSimplified"
  },
  "hash": "02391578dd8e394574059c1f898dfa3a637cc68c54a2028808dedb116a5c7346"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Static initializer references subclass",
  "severity": "High",
  "comment": "Referencing subclass NullMove from superclass Move initializer might lead to class loading deadlock",
  "detailsInfo": "Reports classes that refer to their subclasses in static initializers or static fields. Such references can cause JVM-level deadlocks in multithreaded environment, when one thread tries to load the superclass and another thread tries to load the subclass at the same time. Example:   class Parent {\n    static final Child field = new Child();\n  }\n  class Child extends Parent { }",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/board/Move.java",
      "language": "JAVA",
      "line": 13,
      "offset": 44,
      "length": 8,
      "code": {
        "startLine": 11,
        "length": 8,
        "offset": 127,
        "surroundingCode": "  protected final int destinationCoordinate;\n  protected final boolean isFirstMove;\n  public static final Move NULL_MOVE = new NullMove();\n\n  private Move(Board board, Piece movedPiece, int destinationCoordinate) {"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "StaticInitializerReferencesSubClass"
  },
  "hash": "bc7bb5e90084ec108df13f424268f5649b71f739782847a2722043abea270c22"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Unused assignment",
  "severity": "High",
  "comment": "Variable 'isFirstMove' initializer 'true' is redundant",
  "detailsInfo": "Reports the cases in which a variable is redundant as its value is never used after its assignment. If the variable is not used, it's better to remove it to shorten the code and avoid redundant allocations. The following cases are reported: The variable never gets read after assignment. The value is always overwritten with another assignment before the next variable is read. The variable initializer is redundant (for one of the two reasons above). Configure the inspection: Use the Report redundant initializers option to report redundant initializers: 'int getI() {\n    int i = 0; // redundant initialization\n    i = 2;\n    return i;\n  }' Use the Report ++i when may be replaced with (i + 1) option to report the cases when '++i' expression may be replaced with 'i + 1': 'int preInc(int i) {\n    int res = i;\n    return ++res;\n  }' Use the Report i++ when changed value is not used afterwards option to report the cases when the result of 'i++' expression is not used later: 'int postInc(int i) {\n    int res = i;\n    return res++;\n  }'",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/chess/engine/pieces/Piece.java",
      "language": "JAVA",
      "line": 13,
      "offset": 33,
      "length": 4,
      "code": {
        "startLine": 11,
        "length": 4,
        "offset": 105,
        "surroundingCode": "  private PieceType pieceType;\n  protected final Alliance pieceAlliance;\n  private boolean isFirstMove = true;\n  private final int cachedHashCode;\n"
      }
    }
  ],
  "attributes": {
    "module": "my-app",
    "inspectionName": "UnusedAssignment"
  },
  "hash": "5166a7ec1cd6298a87f36c965537f371162a22dbb1a607dc22dd6a595f0b899a"
}]}